// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/riakclient.proto

#ifndef PROTOBUF_src_2friakclient_2eproto__INCLUDED
#define PROTOBUF_src_2friakclient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_src_2friakclient_2eproto();
void protobuf_AssignDesc_src_2friakclient_2eproto();
void protobuf_ShutdownFile_src_2friakclient_2eproto();

class RpbErrorResp;
class RpbGetClientIdResp;
class RpbSetClientIdReq;
class RpbGetServerInfoResp;
class RpbGetReq;
class RpbGetResp;
class RpbPutReq;
class RpbPutResp;
class RpbDelReq;
class RpbListBucketsResp;
class RpbListKeysReq;
class RpbListKeysResp;
class RpbGetBucketReq;
class RpbGetBucketResp;
class RpbSetBucketReq;
class RpbMapRedReq;
class RpbMapRedResp;
class RpbContent;
class RpbPair;
class RpbLink;
class RpbBucketProps;

// ===================================================================

class RpbErrorResp : public ::google::protobuf::MessageLite {
 public:
  RpbErrorResp();
  virtual ~RpbErrorResp();

  RpbErrorResp(const RpbErrorResp& from);

  inline RpbErrorResp& operator=(const RpbErrorResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbErrorResp& default_instance();

  void Swap(RpbErrorResp* other);

  // implements Message ----------------------------------------------

  RpbErrorResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbErrorResp& from);
  void MergeFrom(const RpbErrorResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes errmsg = 1;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 1;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const void* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();

  // required uint32 errcode = 2;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RpbErrorResp)
 private:
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_errcode();
  inline void clear_has_errcode();

  ::std::string* errmsg_;
  ::google::protobuf::uint32 errcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbErrorResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetClientIdResp : public ::google::protobuf::MessageLite {
 public:
  RpbGetClientIdResp();
  virtual ~RpbGetClientIdResp();

  RpbGetClientIdResp(const RpbGetClientIdResp& from);

  inline RpbGetClientIdResp& operator=(const RpbGetClientIdResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbGetClientIdResp& default_instance();

  void Swap(RpbGetClientIdResp* other);

  // implements Message ----------------------------------------------

  RpbGetClientIdResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbGetClientIdResp& from);
  void MergeFrom(const RpbGetClientIdResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();

  // @@protoc_insertion_point(class_scope:RpbGetClientIdResp)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();

  ::std::string* client_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbGetClientIdResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetClientIdReq : public ::google::protobuf::MessageLite {
 public:
  RpbSetClientIdReq();
  virtual ~RpbSetClientIdReq();

  RpbSetClientIdReq(const RpbSetClientIdReq& from);

  inline RpbSetClientIdReq& operator=(const RpbSetClientIdReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbSetClientIdReq& default_instance();

  void Swap(RpbSetClientIdReq* other);

  // implements Message ----------------------------------------------

  RpbSetClientIdReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbSetClientIdReq& from);
  void MergeFrom(const RpbSetClientIdReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();

  // @@protoc_insertion_point(class_scope:RpbSetClientIdReq)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();

  ::std::string* client_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbSetClientIdReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetServerInfoResp : public ::google::protobuf::MessageLite {
 public:
  RpbGetServerInfoResp();
  virtual ~RpbGetServerInfoResp();

  RpbGetServerInfoResp(const RpbGetServerInfoResp& from);

  inline RpbGetServerInfoResp& operator=(const RpbGetServerInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbGetServerInfoResp& default_instance();

  void Swap(RpbGetServerInfoResp* other);

  // implements Message ----------------------------------------------

  RpbGetServerInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbGetServerInfoResp& from);
  void MergeFrom(const RpbGetServerInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const void* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();

  // optional bytes server_version = 2;
  inline bool has_server_version() const;
  inline void clear_server_version();
  static const int kServerVersionFieldNumber = 2;
  inline const ::std::string& server_version() const;
  inline void set_server_version(const ::std::string& value);
  inline void set_server_version(const char* value);
  inline void set_server_version(const void* value, size_t size);
  inline ::std::string* mutable_server_version();
  inline ::std::string* release_server_version();

  // @@protoc_insertion_point(class_scope:RpbGetServerInfoResp)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_server_version();
  inline void clear_has_server_version();

  ::std::string* node_;
  ::std::string* server_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbGetServerInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetReq : public ::google::protobuf::MessageLite {
 public:
  RpbGetReq();
  virtual ~RpbGetReq();

  RpbGetReq(const RpbGetReq& from);

  inline RpbGetReq& operator=(const RpbGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbGetReq& default_instance();

  void Swap(RpbGetReq* other);

  // implements Message ----------------------------------------------

  RpbGetReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbGetReq& from);
  void MergeFrom(const RpbGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();

  // optional uint32 r = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RpbGetReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_r();
  inline void clear_has_r();

  ::std::string* bucket_;
  ::std::string* key_;
  ::google::protobuf::uint32 r_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbGetReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetResp : public ::google::protobuf::MessageLite {
 public:
  RpbGetResp();
  virtual ~RpbGetResp();

  RpbGetResp(const RpbGetResp& from);

  inline RpbGetResp& operator=(const RpbGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbGetResp& default_instance();

  void Swap(RpbGetResp* other);

  // implements Message ----------------------------------------------

  RpbGetResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbGetResp& from);
  void MergeFrom(const RpbGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::RpbContent& content(int index) const;
  inline ::RpbContent* mutable_content(int index);
  inline ::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
      mutable_content();

  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();

  // @@protoc_insertion_point(class_scope:RpbGetResp)
 private:
  inline void set_has_vclock();
  inline void clear_has_vclock();

  ::google::protobuf::RepeatedPtrField< ::RpbContent > content_;
  ::std::string* vclock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbGetResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutReq : public ::google::protobuf::MessageLite {
 public:
  RpbPutReq();
  virtual ~RpbPutReq();

  RpbPutReq(const RpbPutReq& from);

  inline RpbPutReq& operator=(const RpbPutReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbPutReq& default_instance();

  void Swap(RpbPutReq* other);

  // implements Message ----------------------------------------------

  RpbPutReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbPutReq& from);
  void MergeFrom(const RpbPutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();

  // optional bytes vclock = 3;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 3;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();

  // required .RpbContent content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::RpbContent& content() const;
  inline ::RpbContent* mutable_content();
  inline ::RpbContent* release_content();

  // optional uint32 w = 5;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 5;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);

  // optional uint32 dw = 6;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 6;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);

  // optional bool return_body = 7;
  inline bool has_return_body() const;
  inline void clear_return_body();
  static const int kReturnBodyFieldNumber = 7;
  inline bool return_body() const;
  inline void set_return_body(bool value);

  // @@protoc_insertion_point(class_scope:RpbPutReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_return_body();
  inline void clear_has_return_body();

  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* vclock_;
  ::RpbContent* content_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 dw_;
  bool return_body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbPutReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutResp : public ::google::protobuf::MessageLite {
 public:
  RpbPutResp();
  virtual ~RpbPutResp();

  RpbPutResp(const RpbPutResp& from);

  inline RpbPutResp& operator=(const RpbPutResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbPutResp& default_instance();

  void Swap(RpbPutResp* other);

  // implements Message ----------------------------------------------

  RpbPutResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbPutResp& from);
  void MergeFrom(const RpbPutResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::RpbContent& content(int index) const;
  inline ::RpbContent* mutable_content(int index);
  inline ::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
      mutable_content();

  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();

  // @@protoc_insertion_point(class_scope:RpbPutResp)
 private:
  inline void set_has_vclock();
  inline void clear_has_vclock();

  ::google::protobuf::RepeatedPtrField< ::RpbContent > content_;
  ::std::string* vclock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbPutResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbDelReq : public ::google::protobuf::MessageLite {
 public:
  RpbDelReq();
  virtual ~RpbDelReq();

  RpbDelReq(const RpbDelReq& from);

  inline RpbDelReq& operator=(const RpbDelReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbDelReq& default_instance();

  void Swap(RpbDelReq* other);

  // implements Message ----------------------------------------------

  RpbDelReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbDelReq& from);
  void MergeFrom(const RpbDelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();

  // optional uint32 rw = 3;
  inline bool has_rw() const;
  inline void clear_rw();
  static const int kRwFieldNumber = 3;
  inline ::google::protobuf::uint32 rw() const;
  inline void set_rw(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RpbDelReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_rw();
  inline void clear_has_rw();

  ::std::string* bucket_;
  ::std::string* key_;
  ::google::protobuf::uint32 rw_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbDelReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListBucketsResp : public ::google::protobuf::MessageLite {
 public:
  RpbListBucketsResp();
  virtual ~RpbListBucketsResp();

  RpbListBucketsResp(const RpbListBucketsResp& from);

  inline RpbListBucketsResp& operator=(const RpbListBucketsResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbListBucketsResp& default_instance();

  void Swap(RpbListBucketsResp* other);

  // implements Message ----------------------------------------------

  RpbListBucketsResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbListBucketsResp& from);
  void MergeFrom(const RpbListBucketsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes buckets = 1;
  inline int buckets_size() const;
  inline void clear_buckets();
  static const int kBucketsFieldNumber = 1;
  inline const ::std::string& buckets(int index) const;
  inline ::std::string* mutable_buckets(int index);
  inline void set_buckets(int index, const ::std::string& value);
  inline void set_buckets(int index, const char* value);
  inline void set_buckets(int index, const void* value, size_t size);
  inline ::std::string* add_buckets();
  inline void add_buckets(const ::std::string& value);
  inline void add_buckets(const char* value);
  inline void add_buckets(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& buckets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_buckets();

  // @@protoc_insertion_point(class_scope:RpbListBucketsResp)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> buckets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbListBucketsResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysReq : public ::google::protobuf::MessageLite {
 public:
  RpbListKeysReq();
  virtual ~RpbListKeysReq();

  RpbListKeysReq(const RpbListKeysReq& from);

  inline RpbListKeysReq& operator=(const RpbListKeysReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbListKeysReq& default_instance();

  void Swap(RpbListKeysReq* other);

  // implements Message ----------------------------------------------

  RpbListKeysReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbListKeysReq& from);
  void MergeFrom(const RpbListKeysReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();

  // @@protoc_insertion_point(class_scope:RpbListKeysReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();

  ::std::string* bucket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbListKeysReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysResp : public ::google::protobuf::MessageLite {
 public:
  RpbListKeysResp();
  virtual ~RpbListKeysResp();

  RpbListKeysResp(const RpbListKeysResp& from);

  inline RpbListKeysResp& operator=(const RpbListKeysResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbListKeysResp& default_instance();

  void Swap(RpbListKeysResp* other);

  // implements Message ----------------------------------------------

  RpbListKeysResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbListKeysResp& from);
  void MergeFrom(const RpbListKeysResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // optional bool done = 2;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 2;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbListKeysResp)
 private:
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  bool done_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbListKeysResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketReq : public ::google::protobuf::MessageLite {
 public:
  RpbGetBucketReq();
  virtual ~RpbGetBucketReq();

  RpbGetBucketReq(const RpbGetBucketReq& from);

  inline RpbGetBucketReq& operator=(const RpbGetBucketReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbGetBucketReq& default_instance();

  void Swap(RpbGetBucketReq* other);

  // implements Message ----------------------------------------------

  RpbGetBucketReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbGetBucketReq& from);
  void MergeFrom(const RpbGetBucketReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();

  // @@protoc_insertion_point(class_scope:RpbGetBucketReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();

  ::std::string* bucket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbGetBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketResp : public ::google::protobuf::MessageLite {
 public:
  RpbGetBucketResp();
  virtual ~RpbGetBucketResp();

  RpbGetBucketResp(const RpbGetBucketResp& from);

  inline RpbGetBucketResp& operator=(const RpbGetBucketResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbGetBucketResp& default_instance();

  void Swap(RpbGetBucketResp* other);

  // implements Message ----------------------------------------------

  RpbGetBucketResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbGetBucketResp& from);
  void MergeFrom(const RpbGetBucketResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RpbBucketProps props = 1;
  inline bool has_props() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 1;
  inline const ::RpbBucketProps& props() const;
  inline ::RpbBucketProps* mutable_props();
  inline ::RpbBucketProps* release_props();

  // @@protoc_insertion_point(class_scope:RpbGetBucketResp)
 private:
  inline void set_has_props();
  inline void clear_has_props();

  ::RpbBucketProps* props_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbGetBucketResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetBucketReq : public ::google::protobuf::MessageLite {
 public:
  RpbSetBucketReq();
  virtual ~RpbSetBucketReq();

  RpbSetBucketReq(const RpbSetBucketReq& from);

  inline RpbSetBucketReq& operator=(const RpbSetBucketReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbSetBucketReq& default_instance();

  void Swap(RpbSetBucketReq* other);

  // implements Message ----------------------------------------------

  RpbSetBucketReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbSetBucketReq& from);
  void MergeFrom(const RpbSetBucketReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();

  // required .RpbBucketProps props = 2;
  inline bool has_props() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 2;
  inline const ::RpbBucketProps& props() const;
  inline ::RpbBucketProps* mutable_props();
  inline ::RpbBucketProps* release_props();

  // @@protoc_insertion_point(class_scope:RpbSetBucketReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_props();
  inline void clear_has_props();

  ::std::string* bucket_;
  ::RpbBucketProps* props_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbSetBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedReq : public ::google::protobuf::MessageLite {
 public:
  RpbMapRedReq();
  virtual ~RpbMapRedReq();

  RpbMapRedReq(const RpbMapRedReq& from);

  inline RpbMapRedReq& operator=(const RpbMapRedReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbMapRedReq& default_instance();

  void Swap(RpbMapRedReq* other);

  // implements Message ----------------------------------------------

  RpbMapRedReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbMapRedReq& from);
  void MergeFrom(const RpbMapRedReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::std::string& request() const;
  inline void set_request(const ::std::string& value);
  inline void set_request(const char* value);
  inline void set_request(const void* value, size_t size);
  inline ::std::string* mutable_request();
  inline ::std::string* release_request();

  // required bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();

  // @@protoc_insertion_point(class_scope:RpbMapRedReq)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_content_type();
  inline void clear_has_content_type();

  ::std::string* request_;
  ::std::string* content_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbMapRedReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedResp : public ::google::protobuf::MessageLite {
 public:
  RpbMapRedResp();
  virtual ~RpbMapRedResp();

  RpbMapRedResp(const RpbMapRedResp& from);

  inline RpbMapRedResp& operator=(const RpbMapRedResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbMapRedResp& default_instance();

  void Swap(RpbMapRedResp* other);

  // implements Message ----------------------------------------------

  RpbMapRedResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbMapRedResp& from);
  void MergeFrom(const RpbMapRedResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 phase = 1;
  inline bool has_phase() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 1;
  inline ::google::protobuf::uint32 phase() const;
  inline void set_phase(::google::protobuf::uint32 value);

  // optional bytes response = 2;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const void* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();

  // optional bool done = 3;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbMapRedResp)
 private:
  inline void set_has_phase();
  inline void clear_has_phase();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_done();
  inline void clear_has_done();

  ::std::string* response_;
  ::google::protobuf::uint32 phase_;
  bool done_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbMapRedResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbContent : public ::google::protobuf::MessageLite {
 public:
  RpbContent();
  virtual ~RpbContent();

  RpbContent(const RpbContent& from);

  inline RpbContent& operator=(const RpbContent& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbContent& default_instance();

  void Swap(RpbContent* other);

  // implements Message ----------------------------------------------

  RpbContent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbContent& from);
  void MergeFrom(const RpbContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();

  // optional bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();

  // optional bytes charset = 3;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 3;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const void* value, size_t size);
  inline ::std::string* mutable_charset();
  inline ::std::string* release_charset();

  // optional bytes content_encoding = 4;
  inline bool has_content_encoding() const;
  inline void clear_content_encoding();
  static const int kContentEncodingFieldNumber = 4;
  inline const ::std::string& content_encoding() const;
  inline void set_content_encoding(const ::std::string& value);
  inline void set_content_encoding(const char* value);
  inline void set_content_encoding(const void* value, size_t size);
  inline ::std::string* mutable_content_encoding();
  inline ::std::string* release_content_encoding();

  // optional bytes vtag = 5;
  inline bool has_vtag() const;
  inline void clear_vtag();
  static const int kVtagFieldNumber = 5;
  inline const ::std::string& vtag() const;
  inline void set_vtag(const ::std::string& value);
  inline void set_vtag(const char* value);
  inline void set_vtag(const void* value, size_t size);
  inline ::std::string* mutable_vtag();
  inline ::std::string* release_vtag();

  // repeated .RpbLink links = 6;
  inline int links_size() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 6;
  inline const ::RpbLink& links(int index) const;
  inline ::RpbLink* mutable_links(int index);
  inline ::RpbLink* add_links();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbLink >&
      links() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbLink >*
      mutable_links();

  // optional uint32 last_mod = 7;
  inline bool has_last_mod() const;
  inline void clear_last_mod();
  static const int kLastModFieldNumber = 7;
  inline ::google::protobuf::uint32 last_mod() const;
  inline void set_last_mod(::google::protobuf::uint32 value);

  // optional uint32 last_mod_usecs = 8;
  inline bool has_last_mod_usecs() const;
  inline void clear_last_mod_usecs();
  static const int kLastModUsecsFieldNumber = 8;
  inline ::google::protobuf::uint32 last_mod_usecs() const;
  inline void set_last_mod_usecs(::google::protobuf::uint32 value);

  // repeated .RpbPair usermeta = 9;
  inline int usermeta_size() const;
  inline void clear_usermeta();
  static const int kUsermetaFieldNumber = 9;
  inline const ::RpbPair& usermeta(int index) const;
  inline ::RpbPair* mutable_usermeta(int index);
  inline ::RpbPair* add_usermeta();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      usermeta() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_usermeta();

  // @@protoc_insertion_point(class_scope:RpbContent)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_content_type();
  inline void clear_has_content_type();
  inline void set_has_charset();
  inline void clear_has_charset();
  inline void set_has_content_encoding();
  inline void clear_has_content_encoding();
  inline void set_has_vtag();
  inline void clear_has_vtag();
  inline void set_has_last_mod();
  inline void clear_has_last_mod();
  inline void set_has_last_mod_usecs();
  inline void clear_has_last_mod_usecs();

  ::std::string* value_;
  ::std::string* content_type_;
  ::std::string* charset_;
  ::std::string* content_encoding_;
  ::std::string* vtag_;
  ::google::protobuf::RepeatedPtrField< ::RpbLink > links_;
  ::google::protobuf::uint32 last_mod_;
  ::google::protobuf::uint32 last_mod_usecs_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > usermeta_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbContent* default_instance_;
};
// -------------------------------------------------------------------

class RpbPair : public ::google::protobuf::MessageLite {
 public:
  RpbPair();
  virtual ~RpbPair();

  RpbPair(const RpbPair& from);

  inline RpbPair& operator=(const RpbPair& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbPair& default_instance();

  void Swap(RpbPair* other);

  // implements Message ----------------------------------------------

  RpbPair* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbPair& from);
  void MergeFrom(const RpbPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();

  // @@protoc_insertion_point(class_scope:RpbPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbPair* default_instance_;
};
// -------------------------------------------------------------------

class RpbLink : public ::google::protobuf::MessageLite {
 public:
  RpbLink();
  virtual ~RpbLink();

  RpbLink(const RpbLink& from);

  inline RpbLink& operator=(const RpbLink& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbLink& default_instance();

  void Swap(RpbLink* other);

  // implements Message ----------------------------------------------

  RpbLink* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbLink& from);
  void MergeFrom(const RpbLink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();

  // optional bytes tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const void* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();

  // @@protoc_insertion_point(class_scope:RpbLink)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbLink* default_instance_;
};
// -------------------------------------------------------------------

class RpbBucketProps : public ::google::protobuf::MessageLite {
 public:
  RpbBucketProps();
  virtual ~RpbBucketProps();

  RpbBucketProps(const RpbBucketProps& from);

  inline RpbBucketProps& operator=(const RpbBucketProps& from) {
    CopyFrom(from);
    return *this;
  }

  static const RpbBucketProps& default_instance();

  void Swap(RpbBucketProps* other);

  // implements Message ----------------------------------------------

  RpbBucketProps* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RpbBucketProps& from);
  void MergeFrom(const RpbBucketProps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 n_val = 1;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 1;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bool allow_mult = 2;
  inline bool has_allow_mult() const;
  inline void clear_allow_mult();
  static const int kAllowMultFieldNumber = 2;
  inline bool allow_mult() const;
  inline void set_allow_mult(bool value);

  // @@protoc_insertion_point(class_scope:RpbBucketProps)
 private:
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_allow_mult();
  inline void clear_has_allow_mult();

  ::google::protobuf::uint32 n_val_;
  bool allow_mult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2friakclient_2eproto();
  friend void protobuf_AssignDesc_src_2friakclient_2eproto();
  friend void protobuf_ShutdownFile_src_2friakclient_2eproto();

  void InitAsDefaultInstance();
  static RpbBucketProps* default_instance_;
};
// ===================================================================


// ===================================================================

// RpbErrorResp

// required bytes errmsg = 1;
inline bool RpbErrorResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbErrorResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbErrorResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbErrorResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& RpbErrorResp::errmsg() const {
  return *errmsg_;
}
inline void RpbErrorResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void RpbErrorResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void RpbErrorResp::set_errmsg(const void* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbErrorResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  return errmsg_;
}
inline ::std::string* RpbErrorResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 errcode = 2;
inline bool RpbErrorResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbErrorResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbErrorResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbErrorResp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 RpbErrorResp::errcode() const {
  return errcode_;
}
inline void RpbErrorResp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
}

// -------------------------------------------------------------------

// RpbGetClientIdResp

// required bytes client_id = 1;
inline bool RpbGetClientIdResp::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetClientIdResp::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetClientIdResp::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetClientIdResp::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::kEmptyString) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& RpbGetClientIdResp::client_id() const {
  return *client_id_;
}
inline void RpbGetClientIdResp::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbGetClientIdResp::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbGetClientIdResp::set_client_id(const void* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetClientIdResp::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  return client_id_;
}
inline ::std::string* RpbGetClientIdResp::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbSetClientIdReq

// required bytes client_id = 1;
inline bool RpbSetClientIdReq::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbSetClientIdReq::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbSetClientIdReq::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbSetClientIdReq::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::kEmptyString) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& RpbSetClientIdReq::client_id() const {
  return *client_id_;
}
inline void RpbSetClientIdReq::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbSetClientIdReq::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbSetClientIdReq::set_client_id(const void* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbSetClientIdReq::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  return client_id_;
}
inline ::std::string* RpbSetClientIdReq::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbGetServerInfoResp

// optional bytes node = 1;
inline bool RpbGetServerInfoResp::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetServerInfoResp::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetServerInfoResp::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetServerInfoResp::clear_node() {
  if (node_ != &::google::protobuf::internal::kEmptyString) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& RpbGetServerInfoResp::node() const {
  return *node_;
}
inline void RpbGetServerInfoResp::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void RpbGetServerInfoResp::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void RpbGetServerInfoResp::set_node(const void* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetServerInfoResp::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  return node_;
}
inline ::std::string* RpbGetServerInfoResp::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes server_version = 2;
inline bool RpbGetServerInfoResp::has_server_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetServerInfoResp::set_has_server_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetServerInfoResp::clear_has_server_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetServerInfoResp::clear_server_version() {
  if (server_version_ != &::google::protobuf::internal::kEmptyString) {
    server_version_->clear();
  }
  clear_has_server_version();
}
inline const ::std::string& RpbGetServerInfoResp::server_version() const {
  return *server_version_;
}
inline void RpbGetServerInfoResp::set_server_version(const ::std::string& value) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::kEmptyString) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
}
inline void RpbGetServerInfoResp::set_server_version(const char* value) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::kEmptyString) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
}
inline void RpbGetServerInfoResp::set_server_version(const void* value, size_t size) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::kEmptyString) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetServerInfoResp::mutable_server_version() {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::kEmptyString) {
    server_version_ = new ::std::string;
  }
  return server_version_;
}
inline ::std::string* RpbGetServerInfoResp::release_server_version() {
  clear_has_server_version();
  if (server_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_version_;
    server_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbGetReq

// required bytes bucket = 1;
inline bool RpbGetReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbGetReq::bucket() const {
  return *bucket_;
}
inline void RpbGetReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbGetReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes key = 2;
inline bool RpbGetReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbGetReq::key() const {
  return *key_;
}
inline void RpbGetReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbGetReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbGetReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbGetReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 r = 3;
inline bool RpbGetReq::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbGetReq::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbGetReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbGetReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbGetReq::r() const {
  return r_;
}
inline void RpbGetReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
}

// -------------------------------------------------------------------

// RpbGetResp

// repeated .RpbContent content = 1;
inline int RpbGetResp::content_size() const {
  return content_.size();
}
inline void RpbGetResp::clear_content() {
  content_.Clear();
}
inline const ::RpbContent& RpbGetResp::content(int index) const {
  return content_.Get(index);
}
inline ::RpbContent* RpbGetResp::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::RpbContent* RpbGetResp::add_content() {
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
RpbGetResp::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
RpbGetResp::mutable_content() {
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbGetResp::has_vclock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetResp::set_has_vclock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetResp::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetResp::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::kEmptyString) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbGetResp::vclock() const {
  return *vclock_;
}
inline void RpbGetResp::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbGetResp::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbGetResp::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetResp::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}
inline ::std::string* RpbGetResp::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbPutReq

// required bytes bucket = 1;
inline bool RpbPutReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbPutReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbPutReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbPutReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbPutReq::bucket() const {
  return *bucket_;
}
inline void RpbPutReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbPutReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbPutReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbPutReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes key = 2;
inline bool RpbPutReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPutReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPutReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPutReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPutReq::key() const {
  return *key_;
}
inline void RpbPutReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbPutReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes vclock = 3;
inline bool RpbPutReq::has_vclock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbPutReq::set_has_vclock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbPutReq::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbPutReq::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::kEmptyString) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbPutReq::vclock() const {
  return *vclock_;
}
inline void RpbPutReq::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutReq::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutReq::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}
inline ::std::string* RpbPutReq::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .RpbContent content = 4;
inline bool RpbPutReq::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbPutReq::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbPutReq::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbPutReq::clear_content() {
  if (content_ != NULL) content_->::RpbContent::Clear();
  clear_has_content();
}
inline const ::RpbContent& RpbPutReq::content() const {
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::RpbContent* RpbPutReq::mutable_content() {
  set_has_content();
  if (content_ == NULL) content_ = new ::RpbContent;
  return content_;
}
inline ::RpbContent* RpbPutReq::release_content() {
  clear_has_content();
  ::RpbContent* temp = content_;
  content_ = NULL;
  return temp;
}

// optional uint32 w = 5;
inline bool RpbPutReq::has_w() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbPutReq::set_has_w() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbPutReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbPutReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbPutReq::w() const {
  return w_;
}
inline void RpbPutReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
}

// optional uint32 dw = 6;
inline bool RpbPutReq::has_dw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbPutReq::set_has_dw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbPutReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbPutReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbPutReq::dw() const {
  return dw_;
}
inline void RpbPutReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
}

// optional bool return_body = 7;
inline bool RpbPutReq::has_return_body() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbPutReq::set_has_return_body() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbPutReq::clear_has_return_body() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbPutReq::clear_return_body() {
  return_body_ = false;
  clear_has_return_body();
}
inline bool RpbPutReq::return_body() const {
  return return_body_;
}
inline void RpbPutReq::set_return_body(bool value) {
  set_has_return_body();
  return_body_ = value;
}

// -------------------------------------------------------------------

// RpbPutResp

// repeated .RpbContent content = 1;
inline int RpbPutResp::content_size() const {
  return content_.size();
}
inline void RpbPutResp::clear_content() {
  content_.Clear();
}
inline const ::RpbContent& RpbPutResp::content(int index) const {
  return content_.Get(index);
}
inline ::RpbContent* RpbPutResp::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::RpbContent* RpbPutResp::add_content() {
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
RpbPutResp::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
RpbPutResp::mutable_content() {
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbPutResp::has_vclock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPutResp::set_has_vclock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPutResp::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPutResp::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::kEmptyString) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbPutResp::vclock() const {
  return *vclock_;
}
inline void RpbPutResp::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutResp::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutResp::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutResp::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}
inline ::std::string* RpbPutResp::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbDelReq

// required bytes bucket = 1;
inline bool RpbDelReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbDelReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbDelReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbDelReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbDelReq::bucket() const {
  return *bucket_;
}
inline void RpbDelReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbDelReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbDelReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbDelReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbDelReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes key = 2;
inline bool RpbDelReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbDelReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbDelReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbDelReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbDelReq::key() const {
  return *key_;
}
inline void RpbDelReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbDelReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbDelReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbDelReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbDelReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 rw = 3;
inline bool RpbDelReq::has_rw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbDelReq::set_has_rw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbDelReq::clear_has_rw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbDelReq::clear_rw() {
  rw_ = 0u;
  clear_has_rw();
}
inline ::google::protobuf::uint32 RpbDelReq::rw() const {
  return rw_;
}
inline void RpbDelReq::set_rw(::google::protobuf::uint32 value) {
  set_has_rw();
  rw_ = value;
}

// -------------------------------------------------------------------

// RpbListBucketsResp

// repeated bytes buckets = 1;
inline int RpbListBucketsResp::buckets_size() const {
  return buckets_.size();
}
inline void RpbListBucketsResp::clear_buckets() {
  buckets_.Clear();
}
inline const ::std::string& RpbListBucketsResp::buckets(int index) const {
  return buckets_.Get(index);
}
inline ::std::string* RpbListBucketsResp::mutable_buckets(int index) {
  return buckets_.Mutable(index);
}
inline void RpbListBucketsResp::set_buckets(int index, const ::std::string& value) {
  buckets_.Mutable(index)->assign(value);
}
inline void RpbListBucketsResp::set_buckets(int index, const char* value) {
  buckets_.Mutable(index)->assign(value);
}
inline void RpbListBucketsResp::set_buckets(int index, const void* value, size_t size) {
  buckets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListBucketsResp::add_buckets() {
  return buckets_.Add();
}
inline void RpbListBucketsResp::add_buckets(const ::std::string& value) {
  buckets_.Add()->assign(value);
}
inline void RpbListBucketsResp::add_buckets(const char* value) {
  buckets_.Add()->assign(value);
}
inline void RpbListBucketsResp::add_buckets(const void* value, size_t size) {
  buckets_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListBucketsResp::buckets() const {
  return buckets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListBucketsResp::mutable_buckets() {
  return &buckets_;
}

// -------------------------------------------------------------------

// RpbListKeysReq

// required bytes bucket = 1;
inline bool RpbListKeysReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbListKeysReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbListKeysReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbListKeysReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbListKeysReq::bucket() const {
  return *bucket_;
}
inline void RpbListKeysReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbListKeysReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbListKeysReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListKeysReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbListKeysReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbListKeysResp

// repeated bytes keys = 1;
inline int RpbListKeysResp::keys_size() const {
  return keys_.size();
}
inline void RpbListKeysResp::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RpbListKeysResp::keys(int index) const {
  return keys_.Get(index);
}
inline ::std::string* RpbListKeysResp::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline void RpbListKeysResp::set_keys(int index, const ::std::string& value) {
  keys_.Mutable(index)->assign(value);
}
inline void RpbListKeysResp::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
}
inline void RpbListKeysResp::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListKeysResp::add_keys() {
  return keys_.Add();
}
inline void RpbListKeysResp::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
}
inline void RpbListKeysResp::add_keys(const char* value) {
  keys_.Add()->assign(value);
}
inline void RpbListKeysResp::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListKeysResp::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListKeysResp::mutable_keys() {
  return &keys_;
}

// optional bool done = 2;
inline bool RpbListKeysResp::has_done() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbListKeysResp::set_has_done() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbListKeysResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbListKeysResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbListKeysResp::done() const {
  return done_;
}
inline void RpbListKeysResp::set_done(bool value) {
  set_has_done();
  done_ = value;
}

// -------------------------------------------------------------------

// RpbGetBucketReq

// required bytes bucket = 1;
inline bool RpbGetBucketReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetBucketReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetBucketReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetBucketReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbGetBucketReq::bucket() const {
  return *bucket_;
}
inline void RpbGetBucketReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetBucketReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetBucketReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetBucketReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbGetBucketReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbGetBucketResp

// required .RpbBucketProps props = 1;
inline bool RpbGetBucketResp::has_props() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetBucketResp::set_has_props() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetBucketResp::clear_has_props() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetBucketResp::clear_props() {
  if (props_ != NULL) props_->::RpbBucketProps::Clear();
  clear_has_props();
}
inline const ::RpbBucketProps& RpbGetBucketResp::props() const {
  return props_ != NULL ? *props_ : *default_instance_->props_;
}
inline ::RpbBucketProps* RpbGetBucketResp::mutable_props() {
  set_has_props();
  if (props_ == NULL) props_ = new ::RpbBucketProps;
  return props_;
}
inline ::RpbBucketProps* RpbGetBucketResp::release_props() {
  clear_has_props();
  ::RpbBucketProps* temp = props_;
  props_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RpbSetBucketReq

// required bytes bucket = 1;
inline bool RpbSetBucketReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbSetBucketReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbSetBucketReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbSetBucketReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbSetBucketReq::bucket() const {
  return *bucket_;
}
inline void RpbSetBucketReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbSetBucketReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbSetBucketReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbSetBucketReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbSetBucketReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .RpbBucketProps props = 2;
inline bool RpbSetBucketReq::has_props() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbSetBucketReq::set_has_props() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbSetBucketReq::clear_has_props() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbSetBucketReq::clear_props() {
  if (props_ != NULL) props_->::RpbBucketProps::Clear();
  clear_has_props();
}
inline const ::RpbBucketProps& RpbSetBucketReq::props() const {
  return props_ != NULL ? *props_ : *default_instance_->props_;
}
inline ::RpbBucketProps* RpbSetBucketReq::mutable_props() {
  set_has_props();
  if (props_ == NULL) props_ = new ::RpbBucketProps;
  return props_;
}
inline ::RpbBucketProps* RpbSetBucketReq::release_props() {
  clear_has_props();
  ::RpbBucketProps* temp = props_;
  props_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RpbMapRedReq

// required bytes request = 1;
inline bool RpbMapRedReq::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbMapRedReq::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbMapRedReq::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbMapRedReq::clear_request() {
  if (request_ != &::google::protobuf::internal::kEmptyString) {
    request_->clear();
  }
  clear_has_request();
}
inline const ::std::string& RpbMapRedReq::request() const {
  return *request_;
}
inline void RpbMapRedReq::set_request(const ::std::string& value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void RpbMapRedReq::set_request(const char* value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void RpbMapRedReq::set_request(const void* value, size_t size) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedReq::mutable_request() {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  return request_;
}
inline ::std::string* RpbMapRedReq::release_request() {
  clear_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_;
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes content_type = 2;
inline bool RpbMapRedReq::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbMapRedReq::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbMapRedReq::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbMapRedReq::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::kEmptyString) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& RpbMapRedReq::content_type() const {
  return *content_type_;
}
inline void RpbMapRedReq::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbMapRedReq::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbMapRedReq::set_content_type(const void* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedReq::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  return content_type_;
}
inline ::std::string* RpbMapRedReq::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbMapRedResp

// optional uint32 phase = 1;
inline bool RpbMapRedResp::has_phase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbMapRedResp::set_has_phase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbMapRedResp::clear_has_phase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbMapRedResp::clear_phase() {
  phase_ = 0u;
  clear_has_phase();
}
inline ::google::protobuf::uint32 RpbMapRedResp::phase() const {
  return phase_;
}
inline void RpbMapRedResp::set_phase(::google::protobuf::uint32 value) {
  set_has_phase();
  phase_ = value;
}

// optional bytes response = 2;
inline bool RpbMapRedResp::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbMapRedResp::set_has_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbMapRedResp::clear_has_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbMapRedResp::clear_response() {
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& RpbMapRedResp::response() const {
  return *response_;
}
inline void RpbMapRedResp::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void RpbMapRedResp::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void RpbMapRedResp::set_response(const void* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedResp::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  return response_;
}
inline ::std::string* RpbMapRedResp::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool done = 3;
inline bool RpbMapRedResp::has_done() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbMapRedResp::set_has_done() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbMapRedResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbMapRedResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbMapRedResp::done() const {
  return done_;
}
inline void RpbMapRedResp::set_done(bool value) {
  set_has_done();
  done_ = value;
}

// -------------------------------------------------------------------

// RpbContent

// required bytes value = 1;
inline bool RpbContent::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbContent::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbContent::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbContent::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& RpbContent::value() const {
  return *value_;
}
inline void RpbContent::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbContent::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbContent::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* RpbContent::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes content_type = 2;
inline bool RpbContent::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbContent::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbContent::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbContent::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::kEmptyString) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& RpbContent::content_type() const {
  return *content_type_;
}
inline void RpbContent::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbContent::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbContent::set_content_type(const void* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  return content_type_;
}
inline ::std::string* RpbContent::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes charset = 3;
inline bool RpbContent::has_charset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbContent::set_has_charset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbContent::clear_has_charset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbContent::clear_charset() {
  if (charset_ != &::google::protobuf::internal::kEmptyString) {
    charset_->clear();
  }
  clear_has_charset();
}
inline const ::std::string& RpbContent::charset() const {
  return *charset_;
}
inline void RpbContent::set_charset(const ::std::string& value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RpbContent::set_charset(const char* value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RpbContent::set_charset(const void* value, size_t size) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_charset() {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  return charset_;
}
inline ::std::string* RpbContent::release_charset() {
  clear_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charset_;
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes content_encoding = 4;
inline bool RpbContent::has_content_encoding() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbContent::set_has_content_encoding() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbContent::clear_has_content_encoding() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbContent::clear_content_encoding() {
  if (content_encoding_ != &::google::protobuf::internal::kEmptyString) {
    content_encoding_->clear();
  }
  clear_has_content_encoding();
}
inline const ::std::string& RpbContent::content_encoding() const {
  return *content_encoding_;
}
inline void RpbContent::set_content_encoding(const ::std::string& value) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
}
inline void RpbContent::set_content_encoding(const char* value) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
}
inline void RpbContent::set_content_encoding(const void* value, size_t size) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_content_encoding() {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  return content_encoding_;
}
inline ::std::string* RpbContent::release_content_encoding() {
  clear_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_encoding_;
    content_encoding_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes vtag = 5;
inline bool RpbContent::has_vtag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbContent::set_has_vtag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbContent::clear_has_vtag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbContent::clear_vtag() {
  if (vtag_ != &::google::protobuf::internal::kEmptyString) {
    vtag_->clear();
  }
  clear_has_vtag();
}
inline const ::std::string& RpbContent::vtag() const {
  return *vtag_;
}
inline void RpbContent::set_vtag(const ::std::string& value) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
}
inline void RpbContent::set_vtag(const char* value) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
}
inline void RpbContent::set_vtag(const void* value, size_t size) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_vtag() {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  return vtag_;
}
inline ::std::string* RpbContent::release_vtag() {
  clear_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vtag_;
    vtag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .RpbLink links = 6;
inline int RpbContent::links_size() const {
  return links_.size();
}
inline void RpbContent::clear_links() {
  links_.Clear();
}
inline const ::RpbLink& RpbContent::links(int index) const {
  return links_.Get(index);
}
inline ::RpbLink* RpbContent::mutable_links(int index) {
  return links_.Mutable(index);
}
inline ::RpbLink* RpbContent::add_links() {
  return links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbLink >&
RpbContent::links() const {
  return links_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbLink >*
RpbContent::mutable_links() {
  return &links_;
}

// optional uint32 last_mod = 7;
inline bool RpbContent::has_last_mod() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbContent::set_has_last_mod() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbContent::clear_has_last_mod() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbContent::clear_last_mod() {
  last_mod_ = 0u;
  clear_has_last_mod();
}
inline ::google::protobuf::uint32 RpbContent::last_mod() const {
  return last_mod_;
}
inline void RpbContent::set_last_mod(::google::protobuf::uint32 value) {
  set_has_last_mod();
  last_mod_ = value;
}

// optional uint32 last_mod_usecs = 8;
inline bool RpbContent::has_last_mod_usecs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbContent::set_has_last_mod_usecs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbContent::clear_has_last_mod_usecs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbContent::clear_last_mod_usecs() {
  last_mod_usecs_ = 0u;
  clear_has_last_mod_usecs();
}
inline ::google::protobuf::uint32 RpbContent::last_mod_usecs() const {
  return last_mod_usecs_;
}
inline void RpbContent::set_last_mod_usecs(::google::protobuf::uint32 value) {
  set_has_last_mod_usecs();
  last_mod_usecs_ = value;
}

// repeated .RpbPair usermeta = 9;
inline int RpbContent::usermeta_size() const {
  return usermeta_.size();
}
inline void RpbContent::clear_usermeta() {
  usermeta_.Clear();
}
inline const ::RpbPair& RpbContent::usermeta(int index) const {
  return usermeta_.Get(index);
}
inline ::RpbPair* RpbContent::mutable_usermeta(int index) {
  return usermeta_.Mutable(index);
}
inline ::RpbPair* RpbContent::add_usermeta() {
  return usermeta_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
RpbContent::usermeta() const {
  return usermeta_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
RpbContent::mutable_usermeta() {
  return &usermeta_;
}

// -------------------------------------------------------------------

// RpbPair

// required bytes key = 1;
inline bool RpbPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbPair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPair::key() const {
  return *key_;
}
inline void RpbPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPair::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes value = 2;
inline bool RpbPair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& RpbPair::value() const {
  return *value_;
}
inline void RpbPair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbPair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbPair::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* RpbPair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbLink

// optional bytes bucket = 1;
inline bool RpbLink::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbLink::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbLink::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbLink::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbLink::bucket() const {
  return *bucket_;
}
inline void RpbLink::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbLink::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbLink::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbLink::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes key = 2;
inline bool RpbLink::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbLink::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbLink::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbLink::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbLink::key() const {
  return *key_;
}
inline void RpbLink::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbLink::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbLink::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbLink::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes tag = 3;
inline bool RpbLink::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbLink::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbLink::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbLink::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& RpbLink::tag() const {
  return *tag_;
}
inline void RpbLink::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void RpbLink::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void RpbLink::set_tag(const void* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* RpbLink::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbBucketProps

// optional uint32 n_val = 1;
inline bool RpbBucketProps::has_n_val() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbBucketProps::set_has_n_val() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbBucketProps::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbBucketProps::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 RpbBucketProps::n_val() const {
  return n_val_;
}
inline void RpbBucketProps::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
}

// optional bool allow_mult = 2;
inline bool RpbBucketProps::has_allow_mult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbBucketProps::set_has_allow_mult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbBucketProps::clear_has_allow_mult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbBucketProps::clear_allow_mult() {
  allow_mult_ = false;
  clear_has_allow_mult();
}
inline bool RpbBucketProps::allow_mult() const {
  return allow_mult_;
}
inline void RpbBucketProps::set_allow_mult(bool value) {
  set_has_allow_mult();
  allow_mult_ = value;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_src_2friakclient_2eproto__INCLUDED
